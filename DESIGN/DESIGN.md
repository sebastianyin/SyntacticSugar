#VOOGASalad Design Document
##Syntactic Sugar
========

##Introduction:

The purpose of this program is to implement a rudimentary game engine, so users can create simple 2D games and then subsequently play them. Our goal is to design a platform that is flexible enough to accommodate various versions of a single game genre, such that the user has the ability to easily generate a wide-range of possible games, without explicitly identifying what the game’s specific rules and configurations are. The game genre for our program is ‘Tower Defense’, the general goal of which is to allow the user to build a set of obstacles to block moving enemy characters from reaching a specific point. This basic design specification can easily be extended to generate hundreds of different games, which differ based on three basic parameters: map layout, characters (including enemies), and obstacles. Thus, our game engine will be malleable enough to accommodate any type of generated map, character, and obstacle that the user wants to implement for their custom ‘Tower Defense’ game.
The basic architecture of our program can be split up into the following general elements: game engine, game authoring module, component hierarchy, and data structure, which together make up the entirety of the front- and back-end of our code. More specifically, the game authoring module is responsible for handling the user interaction as well as generating the GUI components necessary to both create and play a game. On the other hand, the game engine is responsible for handling most of the back-end logic (i.e. defining whether the player can walk across a tile or not, based on its state) and is thus in two-way communication with the game authoring module. Similarly, the component hierarchy defines the basic universal parameters that each possible version of ‘Tower Defense’ share, which are set by the user when creating a game and then subsequently updated when the game is being played. Hence, our program will be designed in a way, such that it is open to basic front-end extensions (i.e. accommodating new types of possible enemies), but closed to modification (i.e. the user can’t define a new component, since the component hierarchy is pre-defined and integral in implementing the back-end logic). 

##Overview:

###Game Authoring Module:

As aforementioned, the basic architecture of our program can be split up into four core elements, which work together to establish the functionality of our ‘Tower Defense’ game engine. Though the game authoring module envelopes the entirety of the front-end, it will be split up into sub-components, to make the editor capability of the program more robust. The game authoring module can be divided into a gamePlayCreator class, which implements the IGamePlayCreator interface and has access to the objectEditorCreator class, which implements the IObjectEditorCreator interface. The gamePlayCreator class is responsible for defining the user’s ability to render the map layout and content and utilizes the character editor class to do so. When the user initially opens up the program, the window is occupied by a splash screen, which gives them four options: ‘Game’, ‘Game Editor’, ‘Social Centre’, and ‘Help’. Once the user selects the ‘Game Editor’ option, they enter the game authoring module. This replaces the current scene of the stage, with a new scene which consists of an empty grid and various GUI elements (Main TabView with ‘Add Level, ‘Delete Level’ and ‘Levels’, Secondary TabView with ‘Tiles’, ‘Monsters’, etc. options, Buttons, Sliders, etc). Thus, the user can build each level for their custom game, with each new level resulting in a new empty grid. The gamePlayCreator class allows the user to select a tile, by clicking the ‘Tile’ tab and then subsequently clicking the ‘+’ button, and then place it on the grid. Furthermore, the gamePlayCreator class allows the user to add new character objects, such as towers or enemies. If the user chooses to add a enemy object, they click the ‘Monster’ tab and then click on the ‘+’ button. This opens up a new GUI window, which represents an instance of the objectEditorCreator class. This window has various other GUI elements that allow the user to set the character object’s component configurations (i.e. set health, define gravity settings, etc).  By adding a new character or obstacle, the gamePlayCreator class makes a call to the generate game object method within the objectEditorCreator, and then adds the enemy object to a queue of enemies, which will ultimately randomly spawn on the game grid once the game is played. Once the user has finished creating a level, they can either choose to continue making more levels or decide to actually create an instance of their custom game by clicking the ‘Save’ option, which notifies the data structure portion of the code to generate a new XML file based on the new user-defined game.

###Game Engine:

The Game Engine is the module of the project that is responsible for playing a game that has been created by the user in the authoring environment. The game created in the authoring environment will be written out to a set of data files (XML files, in this case). These data files will represent the interaction layer between the engine and the authoring environment (that is, the authoring environment generates XML data files representing a “game”, and the engine takes a set of data files representing a “game” and interprets them. That is, the engine will create a set of Java objects from the XML, and then run the basic game loop to allow the user to play the game that they have created. The basic game engine will loop over all relevant Game Objects in the GUI, calling their respective update() method(s). This method will be the driving force behind all state updates in the back end of the game, and will make cascading method calls to handle movement, collision detection, key input processing, and more on an object-by-object basis

###Game Object Hierarchy:

The Game Object class is the most abstract class in the back end. Any game object that will be used by the game engine is derived from this class. It specifies the location of the object and what it looks like to the user. To accomplish this, it will implement the IView interface.
The three subclasses of Game Object are Game Character, Game Item, and Game Tower, all of which are abstract as well. What differentiates these classes from Game Object 	are different interfaces that specify more the functionality of a Game Object. Game Character implements IMoveable, which allows an object to move. Game Tower implements ITileObstacle, an interface that gives an object a blockPath() method. A Game Item implements IGameItem, which contains a use() method that will specify what happens when a particular Game Item object is used.

###Data Structure: 

The XML file format will be used to store all dynamic elements. The XMLIO class will contain methods which convert (and validate) XML into Java objects and Java objects into XML Strings/Files. XStream will be used to serialize these concrete objects. Instead of replicating a Game component multiple times within an XML file (or among multiple XML files), the XML file will contain one instance of every map, enemy, player, and tower within its root element, as well as references to  these maps, enemies, players, and towers within each of the level elements which are also contained by the root element. These references are simply integers which are keys to the single-instanced elements which are contained within a (hash)map. The data structure uses the validate() method which is inherited from the basic GameObject object, which validates an object before and after XML serialization. Note that the data structure only deals with concrete classes, not interfaces. 

##User Interface:

The user will interact with the interface through a series of menu and game screens. The user interface will be presented based on the user’s selection of different modes. This explanation will demonstrate the user interactions related to the screens that are available. From the user’s standpoint, the game is represented in two forms. From a data and file standpoints, the game is represented by a single XML file that stores all of the game objects and preferences and even includes information about game state given that a certain level has been saved during game play. The game is also represented visually to the user during game play and game editing. Based on the game genres that we will be attempting to implement, the game will be represented by a series of tiles and objects on a grid representing a game map. In addition to the map on screen, there will be a visual queue into which the user can click and place enemies to spawn on screen in a certain order. While the game is being played, this map will represent the entire game play area with the exception of the menu where the player will be able to select towers to place on screen and be able to view resources such as money, power-ups, etc. If the user does not wish to create a game on the spot, there will be some default settings, maps, objects, and already designed games that can be automatically loaded into the game engine and played by any user. 


![Image of Splash](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/Splash.png)
![Image of MainMenu](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/MainMenu.png)
![Image of GameSelect](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/GameSelect.png)
![Image of GameMenu](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/GameMenu.png)
![Image of GameEditor](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/GameEditor.png)
![Image of ObjectCreator](https://github.com/duke-compsci308-fall2015/voogasalad_SyntacticSugar/blob/master/DESIGN/ObjectCreator.png)


While the game engine is loading, it will display a splash screen that will fade into the main menu (Image 1). Once the game engine loads, it will automatically direct the user to the main menu that will have options to play a game, go to the editor, go to the social center, or go to an HTML help page. When the user clicks on one of the options, the user will be directed to a new menu or page. 

If the user selects the game player option, the user will be directed to a menu to select a game corresponding to an XML file from a drop down menu. Once a game has been selected, the user will be directed to another screen with the options to play the game from the first level for play from the last saved level. In addition, there will be options to set preferences, switch to the game editor, or go to the help screen. Selecting either of the play options will direct the user to the play screen where the user will see the level of the game being played along with a tab pane that will display towers and other objects that can be placed on screen during game play. The user will be able to click on the icon in the tab pane and then click on a location in the map to place the object. The map will have a snap-to-grid format so that each object takes up a single tile space. 

If the user selects the game editor option, the user will be directed to an editor screen that divided in two parts. On the left hand side, an interactive map canvas will be displayed. The user will be able to populate the map with different tiles and monsters. The user will also be able to click buttons to add and delete levels and change levels in a drop down menu. On the right hand side, an object editor will allow the user to select from a library of default and created tiles, towers, and monsters and also be able to set preferences. The user will click on different tabs to see the different options for each category. Once the user feels that a level is complete, the user will be able to click a play button on the right hand side to directly open a game playing window associated with the game being designed at that moment. The user will also be able to save the current game and its levels to an XML file. 

From the game editor pane, there will be a button, displayed with a + sign,  that allows the user to create custom towers, monsters, and tiles. Clicking this button will cause an object creator window to pop up. This will allow the user to create custom objects by setting a name, image, adding components, etc. These will all correspond to drop down menus, text input boxes, sliding bars, and other forms of user data input. In addition, it should be possible to set character movements based on key inputs. The user should be able to set these key values in the form of a single character or recognizable strings for buttons like “shift” to control the character. 

If the user has uploaded a file that has bad data or incomplete data, this will be detected when the user selects a document after clicking the load button. If the parser is not able to directly parse the information and acquire all of its necessary information, it will throw an error and display an error pop-up with indicative error warnings without proceeding to the next screen so that the user is unable to continue with incomplete information. 


##Design Details 


###Game Authoring Module:

In order to implement the game authoring module, we use the following three main classes: gamePlayCreator, objectEditorCreator, and splashScreenCreator. The three of these implement their own respective interfaces, and are then used to set the content of the program stage’s current scene. For example, when first opening the program, the splashScreenCreator class is used. This class consists of the basic menu GUI elements described in the Overview and User Interface sections above, giving the user the option to either edit or play a game. 
In the case that they choose the ‘Game Editor’ option, an instance of the gamePlayCreator class is instantiated. Each of these classes define the main back-end components to generate their respective scenes (i.e. generating appropriate GUI elements, including toolbars). In order to determine which ‘creator’ class should be instantiated, based on which button is clicked, we will utilize factories and reflection, such that each possible GUI element (comboBox, button, etc) has it’s own associated factory (i.e. comboBoxFactory, buttonFactory, etc). Thus, whenever any button is clicked by the user, the game authoring module can use reflection to easily determine, what the resultant action should be. Hence, the game authoring module, which we utilize only when in ‘Editor’ mode, has its own backend, which communicates directly with its front-end. 
Similarly, once the user is in ‘Editor’ mode and they choose to instantiate a new character object (i.e. enemy, player or tower), gamePlayCreator calls a new instance of the objectEditorCreator class. Any time the objectEditorCreator is initialized, a new stage and corresponding scene are generated. Depending on the type of object, it is either added to a queue (i.e. enemy) to be randomly spawned on the grid during game play, or positioned directly on the grid by the user (i.e. tower or player). The objectEditorCreator GUI consists of a toolbar, which gives the user to set the object’s component parameters. Since the objectEditorCreator implements the IEditor interface, a call to the 
‘setAttribute(Attribute a)’ method is made. Whereas the gamePlayCreator class implements only the IGameEditor interface, the objectEditorCreator relies on a hierarchy of interfaces, with IEditor being at the top level and other interfaces such as (ITowerEditor, IEnemyEditor, etc) extending the IEditor interface. Since there are different types of character objects, using an abstract interface and corresponding sub-Interfaces makes the internal reflection (used to distinguish between types of GUI events) within the game authoring module somewhat easier. 
In turn, when in ‘Editor’ mode, the game authoring module handles its own back-end logic internally, with information being sent to the rest of the program’s core back-end only once the user chooses to ‘Save’ their custom game. As aforementioned, in ‘Editor’ mode, the game authoring module is used to generate XML files for user-defined games, however, once the user enters ‘Game Playing’ mode, there is two-way communication between the game engine and the front-end, which in this case has no internal backend associated with it (i.e. doesn’t have to utilize GUI component factories), since parameters can’t be set or altered once the game is being played. 


##Game Engine:

###Game Object Hierarchy:

The Game Object is the most abstract object that represents an agent in the game and specifies the location of an agent and what that object will look like. It will contain a field called location, which will specify the coordinate or the point in the game that the object occupies. To specify what the object looks like, it will contain a String called image which will specify the path for the particular image file that will be used. Game Object will implement IView, which contains two methods: setImage(String path) and getImage(). The setImage() method will be called when a Game Object is constructed that creates an ImageView from the path represented by image. The same ImageView object will be used in the front end/GUI.
The Game Item subclass represents an object that has some utility or function to another object in the game. For example, Weapon could be an example subclass for the Game Item class. Game Item implements an interface called IGameItem which contains the use() method. This method specifies what happens when an object uses that particular Game Item. In the Weapon example, this method could generate a Bullet object with a particular heading, velocity, damage, etc.
The Game Character subclass represents a subclass that can move. It implements the IMoveable interface that contains the move(). The Game Character has two subclasses: Player and Enemy. Player represents a user-controlled Game Character. Therefore, its move method will be written to handle key input to perform different movement algorithms. The Enemy subclass can be subclassed further into two other subclasses: Stationary Enemy and Movable Enemy. Stationary Enemy will have an empty move method. Movable Enemy will have a movement algorithm that is executed by the move method.
The Game Tower is a subclass that represents an object is permanently affixed to a tile in the game. It does this through the ITileObstacle interface and the blockPath() method. This method changes whether or not a Tile is walkable in the game. Towers can be subdivided further into two groups. One group or subclass could contain Towers that simply block the path so that Players, Enemies, etc. cannot walk on that Tile. Another potential subclass would do the same thing but could contain additional functionality that allows the Tower to spawn or generate other objects. For example, a BulletTower could occupy/block a tile as well as generate Bullets with some sort of internal factory pattern.
	

##Example games

###Bloons Tower Defense

Bloons Tower Defense uses ‘Towers’ and ‘Enemies’ but no players. The enemies are balloons, and the player places monkeys (i.e. towers) to pop them. In the editor, the user will have to design the path for the balloons, as well as deciding which monkeys the player will be allowed to deploy in each level. 

###PacMan
PacMan is an all-time favorite of adults and children. The basic gameplay involves a yellow spherical character that moves around a maze. Its goal is to obtain as many coins as possible, which he obtains by touching them. It has to avoid being touched by blue ghosts, which will scare him and cause the game to end. The blue ghosts will be following Pac-Man around the maze via a set of predefined movement algorithms that we provide the user of the Syntactic Sugar environment. If Pac-Man picks up a power up, he becomes faster and is able to eat the ghosts, which will then try to escape. 
In the editor, the user will be primarily concerned about designing the maze and deciding where the blue ghosts will span. 

###Defender
Defender has ‘Towers’ and ‘Enemies’ but no players. The game contains both walking and flying enemies as well as ‘Towers’ who can shoot at walking, flying, or either enemies. The Towers have two upgrade paths (Generalist and Specialist), which upgrade either the general stats (damage) or special stats (special skill damage). The objective of the game is to stop the enemies which spawn at one or more entrances from reaching the one or more destinations. If an enemy reaches the destination, it respawns at the entrance with the health it had at the end of the path. When a number of enemies have reached the destination, the game is lost. When a number of waves of enemies (levels) are stopped, the game is won. The primary difference between this game and BTD is that upgrades don’t change the functionality of a tower. 


##Design Considerations 
One of the first issues we debated is how to handle collisions. This will be a central issue to our design, as it includes both front and back end. A first problem was how to determine the logic for collisions. One design option we considered was to create a Collision object, that will be created whenever two game objects collide. This collision obejct would then determine how the two objects interact. Furthermore, we like the idea of having the attribute of GameObject interact with each other. For example, a damage attribute would always affect a health attribute, and so on. We also considered the possibility of having our GameObject classes implement a Collider/Collidable interface. For example, an enemy would be a Collidable, and a missile would be a Collider. One of our main concerns when discussing collision was to avoid type casting, but we have yet to find an ideal solution. Another concern we have is how to be able to detect collisions efficiently, without checking every possible pair of objects in the game. 
Another important design consideration is how we will execute the timeline and reflect changes on the view. In particular, we were thinking of implementing an observer/observable pattern, so that we could update only the elements that changed position/state. 

##Team Responsibilities
This section describes the program modules each team member plans to take primary and secondary responsibility for and a high-level plan of how the team will complete the program.

1. Game Editor: Michael (BE/FE), Sebastian(BE), Jiawei(BE), Emanuele (FE), Arthur (FE)
2. Game Object Editor: Henry (BE/FE), Elsie (BE/FE), Brody (BE), Jiawei (BE)
3. Game Engine: Sebastian (BE), Jiawei (FE), Nick (BE/FE), Henry (BE), Emanuele (BE/FE)
4. Component Hierarchy: Jiawei, Nick, Brody, Elsie

###Data Structure: 
Jiawei Zhang - handling XML serialization and concrete object storage/referencing
Arthur Schweitzer - game authoring module

